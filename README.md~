# README

# 목차

# Demo Video (result preview)

[[walk-talk] 걸음 수 기반 채팅 어플 데모 영상](https://codenme.tistory.com/72)

# API SPEC

Swagger-UI

[http://3.37.137.127:21903/swagger-ui/index.html#](http://3.37.137.127:21903/swagger-ui/index.html#)

위의 Swagger-UI를 활용하여  API설명을 확인하고 실제 API 테스트를 수행하실 수 도 있습니다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled.png)

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%201.png)

Swagger- UI 에 적힌 설명을 따라 테스트 access 토큰을 발급받은 뒤 위의 화면에서 아래와 같이 Bearer과 1칸의 공백 뒤에 발급 받은 토큰을 붙여넣고 위의 창에서 Authorize수행 시, 모든 request에서 해당 토큰을 사용하여 인증에 통과할 수 있게 됩니다.

```
Bearer 발급받은액섹스토큰
```

# Purpose

## MileStone 1 API SPEC OverView

요구사항에 포함된 간단한 채팅 기능만 들어있는 MileStone1의 API SPEC 입니다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%202.png)

## MileStone 2 API SPEC OverView

친구 기능, 채팅방 기능을 추가한 MileStone2의 API SPEC 입니다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%203.png)

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%204.png)

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%205.png)

# Purpose

## what?

유저의 실시간 걸음 수를 채팅방에서 랭킹 리스트로 확인하고, 이를 기반으로 경쟁하는 유저 걸음 수 기반 경쟁 채팅 플랫폼인 WALK-TALK를 개발합니다.

## why?

이 앱은 유저들의 걸음 수를 기록하고, 이를 기반으로 걸음수에 대한 랭킹을 제공합니다. 이 랭킹은 건강한 라이프스타일을 촉진하기 위한 것으로, 유저들이 건강한 삶의 습관을 형성하고 유지할 수 있도록 도와줍니다.

또한, 건강한 라이프스타일을 추구하는 유저들 간의 채팅을 통해, 건강의 선순환을 유발하는 것에 더해 건강에 관심이 많은 사용자들간의 경쟁의식을 유발하여, 유저들 간의 건강 경쟁을 통해 더욱 건강한 삶의 습관을 형성하도록 지원합니다.

# Coding Convention

[code convention](https://www.notion.so/code-convention-402842f4a27e4ca88f753b2b209dd7d1?pvs=21) 문서를 참고하세요.

# I**nitial Requirement**

초기 요구사항입니다. MileStone 1에서는 모든 초기 요구사항을 완료한 뒤, MileStone2에서는 부가 기능을 구현하여 어플을 완성하였습니다.

기능

- ~~회원관리 (Security, JWT 적용)~~
    - ~~회원가입 : 필수정보~~
        - ~~id (PK)~~
        - ~~email (UK)~~
        - ~~nickname~~
        - ~~created_date~~
        - ~~modified_date~~
    - ~~로그인 : 소셜로그인 (정보 이메일)~~
        - ~~구글~~
    - ~~로그인 엑세스토큰 만료시간 : 5분 (조정)~~
    - ~~로그인 리프레시 토큰 만료시간 1시간 (조정)~~
- ~~걷기 기록 API~~
    - ~~가라로…. 걸음 수는 숫자로 데이터를 받아온다. (한시간 마다 - 변화가 있으면 저장)~~
    - ~~실시간 데이터는 연구가 필요하다. - 앱에서 도와줘야한다.)~~
    - ~~필수~~
        - ~~id (PK)~~
        - ~~user_id(FK)~~
        - ~~step~~
        - ~~created_date~~
        - ~~modified_date (Opt)~~
    - ~~POST create~~
    - ~~GET - list/{user_id}~~
    - ~~GET - {id}~~
    - ~~TODO… user_id 별로 걷기기록 관리~~
- ~~랭킹 API~~
    - ~~오늘 나의 걸음거리 API~~
    - ~~오늘 모든 회원 걷기 랭킹 API (1~5위까지 리스트 and 내 순위 )~~
        - ~~내순위가 5위 이하이면 리스트 5개까지~~
        - ~~내순위가 6위 이상이면 리스트 5개 + 하단에 내 순위~~
        - ~~순위는 걸음걸이가 많은 순으로~~
        - ~~동점자 처리~~
            - ~~동점자는 같은 순위~~
            - ~~그다음 순위 = 동점자 순위 + 동점자 명수~~
            - ~~dense_rank()~~
            - ~~동점자끼리는 user_id 순서대로~~
        - ~~TODO 스트레스 테스트 할 예정~~
- ~~exception 처리 - controller advice~~
- ~~swagger-ui~~
- ~~TODO 채팅~~

# User Scenario

[walk-talk 시나리오](https://www.notion.so/walk-talk-e3210f7c697744f09035c346ad1e3169?pvs=21)

# ERD

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%206.png)

# Authentication, Authorization

[walk-talk 인증 방식  정리 문서](https://www.notion.so/walk-talk-0ac943c21e434a5e9d55cf34f22226f6?pvs=21) 

Stateless Rest API with JWT

**Authentication:** 구글 로그인 api 사용하여 로드한 사용자 정보를 인증한 뒤, 자체적인 access, refresh 토큰을 사용. 

**Authorization:** 매 요청마다 토큰 속의 정보를 API CheckFilter를 통해 validate합니다.

## JWT Token

### **Access Token**

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%207.png)

### **Refresh Token**

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%208.png)

refresh 토큰은 UserToken 테이블에 저장해서 관리합니다.

# Optimization

## query optimization

### query 횟수 최적화

모든 연관관계는 Lazy-fetch로 설계되어있다.

각 메소드마다, join해야될 테이블을 미리 querydsl을 통해 fetch join으로 가져오는 것으로 추가적인 쿼리가 나가지 않게 하는 것으로 query 횟수를 최적화하였다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%209.png)

또한 querydsl을 통해 구현한 repositoryImpl 가 implements하는 ClubMemberRepositoryCustom
를 repository가 상속하는 것으로, repository를 통해 querydsl을 통해 구현한 쿼리와 JPA를 사용하여 구현한 쿼리 둘 모두를 사용할 수 있도록 구조를 설계하였다.

repositoryImpl

```java
@Repository
@RequiredArgsConstructor
@Log4j2
public class ClubMemberRepositoryImpl  implements ClubMemberRepositoryCustom{

    private final JPAQueryFactory queryFactory;

    public ClubMemberDTO getClubMemberDTOWithStepAndUserTokenByEmail(String email) {
        log.info("querydsl1");
        QClubMember qClubMember = QClubMember.clubMember;
        QUserToken qUserToken = QUserToken.userToken;
        QStep qStep = QStep.step;
        return queryFactory.select(
                        Projections.constructor(
                                ClubMemberDTO.class,
                                qClubMember.id,
                                qClubMember.email,
                                qClubMember.name,
                                qUserToken.refreshToken,
                                qStep.stepCount
                        )
                )
                .from(qClubMember)
                .leftJoin(qClubMember.userToken, qUserToken).fetchJoin()
                .leftJoin(qClubMember.step, qStep).fetchJoin()
                .where(qClubMember.email.eq(email))
                .fetchOne();

    }
..............
}
```

repositoryCustom

```java
public interface ClubMemberRepositoryCustom {
    ClubMemberDTO getClubMemberDTOWithStepAndUserTokenByEmail(String email);

    ClubMember getClubMemberWithStepAndUserTokenByEmail(String email);

    ClubMember getClubMemberWithUserTokenById(Long id);
    ClubMember getClubMemberWithStepById(Long id);
}
```

repository

```java
public interface ClubMemberRepository extends JpaRepository<ClubMember, Long>,ClubMemberRepositoryCustom {
   
.....
}
```

## indexing

```java
@Table(
        name="friend",
        uniqueConstraints={
                @UniqueConstraint(
                        name = "follow_uk", //FK,UK 에 대해 자동으로 인덱스 생성되기에 별도로 생성하지 않는다. + Status는 수정 가능성이 높기에, index로 설정하지 않는다.
                        columnNames={"from_member","to_member"}  //from-> to 중복되지 않게.

                )
        }
        ,
                indexes = {
               // @Index(name = "friend_index", columnList = "from_member, to_member")  //status 도..?
                @Index(name = "friend_index", columnList = "from_member, to_member")// status는 수정이 빈번하기에, index로 만들어주면 인덱스 유지 비용이 높다.
        }
)
```

friend 테이블은 매핑 테이블로, from_member, to_member 두개의 FK가 UK로 제약조건을 걸어두었습니다.

이는 논리적으로도 알맞고, friend 테이블의 대부분의 search는 from_member, to_member로 이루어지기에, 이를 UK로 만들고 index를 형성하는 것으로 search time을 optimize하였습니다.

UK, FK, PK의 경우, mariaDB가 디폴트로 index를 형성에 주기에 별도로 인덱스를 생성하지 않았지만,

friend 테이블의 경우 2개의 MEMEBER엔티티와 관계를 가지고 있기에, from_member의 인덱스가 형성되지 않는 것이 확인되어 해당 필드에 대한 인덱스만 추가로 생성하였습니다.

아래 글은 제가 프로젝트 내에서 indexing을 통한 query cost estimation을 수행한 내용의 글입니다.

[indexing 적용 전 후 query cost estimation 글](https://codenme.tistory.com/83)

## caching

### 캐싱 대상 선택 기준

캐싱 대상의 선정 기준은 업데이트가 상대적으로 적고, 많은 사용 횟수를 기록하는 데이터를 기준으로 선정했습니다.

채팅방 내의 모든 멤버에 대한 정보는 

1) 자신을 제외한 모든 채팅방 내의 멤버에게 메세지를 보내 fcm push 를 수행할 때 채팅방내의 멤버들간 걸음 수 랭킹을 비교할 때 사용되는데, 채팅을 보내는 로직이 가장 많이 수행되는 로직이기에 캐싱을 사용하였습니다.

또한 “자신을 제외한 나머지 멤버” 로 캐싱하지 않고, “모든 채팅방 멤버” 를 캐싱한 뒤,

결과값에서 자신을 제외하는 것으로 cache 메모리의 부하를 감소시켰습니다.

### 내장 캐싱 vs redis로 별도의 캐싱 서버 운영

스프링 내장 캐시와 Redis를 통해 별도의 캐시 서버를 운용하는 것 간에는 몇 가지 장단점이 있습니다.

스프링 내장 캐시의 장점:

1. 간편한 설정: 스프링 프레임워크에서 제공하는 내장 캐시는 설정이 비교적 간단합니다. 응용 프로그램에 캐시를 적용하려면 추가적인 서버나 구성이 필요하지 않습니다.
2. 개발 생산성: 스프링 내장 캐시는 개발 생산성을 향상시킬 수 있습니다. 캐시 로직을 구현하고 관리하는 과정이 단순화되어 개발자가 빠르게 캐시를 활용할 수 있습니다.

스프링 내장 캐시의 단점:

1. 제한된 확장성: 스프링 내장 캐시는 주로 메모리 기반으로 작동하며, 애플리케이션의 메모리를 사용합니다. 따라서 대용량 데이터나 분산 시스템에서의 확장성이 제한될 수 있습니다.
2. 공유 캐시 불가능: 스프링 내장 캐시는 단일 서버 내에서만 동작하므로 여러 서버 간에 캐시를 공유하기 어렵습니다.

Redis를 통한 별도의 캐시 서버의 장점:

1. 확장성: Redis는 분산 시스템으로 설계되어 있으며, 대용량 데이터를 처리하는 데 효과적입니다. Redis를 사용하면 여러 서버 간에 캐시를 공유하고, 필요에 따라 클러스터를 구성하여 확장할 수 있습니다.
2. 다양한 기능: Redis는 다양한 데이터 구조와 기능을 제공합니다. 문자열, 해시, 목록, 집합, 정렬된 집합 등 다양한 데이터 유형을 지원하며, TTL(시간 제한) 설정, 트랜잭션, 패턴 매칭 등 고급 캐싱 기능을 제공합니다.

Redis를 통한 별도의 캐시 서버의 단점:

1. 추가적인 구성 및 관리: Redis를 사용하기 위해서는 별도의 서버를 설정하고 운영해야 합니다. 이에 따라 인프라 구성과 관리에 대한 추가적인 작업이 필요합니다.
2. 성능 영향: 네트워크를 통해 Redis 서버에 접근해야 하므로 스프링 내장 캐시보다는 약간의 성능 영향이 있을 수 있습니다. 특히, Redis 서버와 애플리케이션 서버 간의 네트워크 지연이나 부하가 있을 경우에는 캐시 접근 시간이 증가할 수 있습니다.

요약하면, 스프링 내장 캐시는 간단한 설정과 개발 생산성을 제공하지만, 대용량 데이터나 분산 시스템에서의 확장성과 공유 캐시 기능에는 제한이 있습니다. 반면에 Redis를 통한 별도의 캐시 서버는 확장성이 우수하고 다양한 기능을 제공하지만, 추가적인 구성과 관리가 필요하며 약간의 성능 영향이 있을 수 있습니다. 

### Lettuce VS Jedis

Lettuce: Multi-Thread 에서 Thread-Safe한 Redis 클라이언트로 netty에 의해 관리된다.
Sentinel, Cluster, Redis data model 같은 고급 기능들을 지원하며
비동기 방식으로 요청하기에 TPS/CPU/Connection 개수와 응답속도 등 전 분야에서 Jedis 보다 뛰어나다.
스프링 부트의 기본 의존성은 현재 Lettuce로 되어있다.

Jedis  : Multi-Thread 에서 Thread-unsafe 하며 Connection pool을 이용해 멀티쓰레드 환경을 구성한다.
Jedis 인스턴스와 연결할 때마다 Connection pool을 불러오고 스레드 갯수가
늘어난다면 시간이 상당히 소요될 수 있다.

### 스프링 내장 캐시 적용(deprecated)

**캐싱**

```java
@Cacheable(value = "chatRoom", key = "#chatRoomId")
    @Override
    public List<ClubMember> findAllMemberIdsByChatRoomId(Long chatRoomId) {
        List<MemberChatRoom> allByChatRoomId = memberChatRoomRepository.findAllByChatRoomIdWithChatRoomAndClubMember(chatRoomId);
        if(allByChatRoomId.isEmpty()) throw new RestApiException(CommonErrorResponseCode.RESOURCE_NOT_FOUND);
        return allByChatRoomId.stream()
                .map(MemberChatRoom::getClubMember)
                .collect(Collectors.toList());
    }
```

채팅방의 모든 멤버를 구하는 메소드를 캐싱

**캐시 제거 evict**

```java
@Override
     @Transactional
     @CacheEvict(value = "chatRoom", key = "#chatRoomId")
    //채팅방에 유저 추가. 기존의 채팅방 멤버에 대한 캐시는 불필요해졌기에, 제거한다 (업데이트보다 이편이 전체적으로 나은 성능 예상)
    public void inviteMemberToChatRoom(Long memberId, ChatRoom chatRoom) {
        ClubMember findMember = clubMemberService.findEntityById(memberId);
        addMemberToChatRoom(findMember, chatRoom);

    }
```

위의 메소드는 채팅방에 유저를 초대하는 로직이다. 채팅방에 유저 초대, 채팅방 나가기 등, 채팅방 내의 멤버에 변동이 생기면, 기존의 cache는 일관성을 유지하지 못하기에 잘못된 값이 된다.

따라서 캐시를 업데이트, 혹은 삭제해야하는데, 현재 캐싱하는 값은 채팅방 내의 유저들의 id 를 모아둔 java

콜렉션이기에, 업데이트의 cost 보다 제거 후 다시 캐싱하는 것이 더 효율적이다.

하지만, 스프링 내장 캐시는 여러 한계점이 존재하기에, 캐시 서버를 따로 redis를 통해 관리하는 것으로 변경하였다.

### redis(now implementing)

**유저 캐시** 

 redis repository를 사용하여 구현하였다.

```java
@Service
@RequiredArgsConstructor
public class MemberRedisService {
    private final MemberCacheRedisRepository memberCacheRedisRepository;

    public void setMemberCacheByClubMember(ClubMember clubMember) {
        memberCacheRedisRepository.save(MemberCacheDTO.builder()
                .id(clubMember.getId())
                .tokenId(clubMember.getUserToken().getId())
                .fcmToken(clubMember.getUserToken().getFcmToken())
                .refreshToken(clubMember.getUserToken().getRefreshToken())
                .build());
    }

    public void updateMemberCacheByClubMember(ClubMember clubMember) {
     
        memberCacheRedisRepository.findById(clubMember.getId()).orElseThrow(() -> new RestApiException(CommonErrorResponseCode.RESOURCE_NOT_FOUND));
        memberCacheRedisRepository.save(MemberCacheDTO.builder()
                .id(clubMember.getId())
                .tokenId(clubMember.getUserToken().getId())
                .fcmToken(clubMember.getUserToken().getFcmToken())
                .refreshToken(clubMember.getUserToken().getRefreshToken())
                .build());
    }

    public Optional<MemberCacheDTO> getMemberCacheByClubMemberId(Long clubMemberId) {
        return memberCacheRedisRepository.findById(clubMemberId);
    }

    public void deleteMemberCachesExceptMeByFcmToken(String fcmToken, Long userTokenId) {
        List<MemberCacheDTO> findList = memberCacheRedisRepository.findMemberCachesByFcmToken(fcmToken);
        for (MemberCacheDTO memberCacheDTO : findList) {
            if (memberCacheDTO.getTokenId().equals(userTokenId)) continue;
            memberCacheRedisRepository.delete(memberCacheDTO);
        }
    }
}
```

### 채팅방 멤버 캐시

 “chatroom:2” 는 chatroom:채팅방id 의 형식으로 구성된 key 값이다.

```java
@Service
@RequiredArgsConstructor
@Log4j2
public class RoomMemberRedisService {
    public static final String CHATROOMCACHEKEY = "chatroom:";
    private final ClubMemberRedisRepository clubMemberRedisRepository;

    public void cacheDelete(Long chatRoomId) {
        String cacheKey = CHATROOMCACHEKEY + chatRoomId.toString();
        clubMemberRedisRepository.delete(cacheKey);
    }

    public List<ChatRoomCacheDTO> findChatRoomMembersCacheByChatRoomId(Long chatRoomId) { //if 이 값 == null 캐시 존재 x
        String cacheKey = CHATROOMCACHEKEY + chatRoomId.toString();
        return clubMemberRedisRepository.findAll(cacheKey);
    }

    public void saveChatRoomMembersCache(Long chatRoomId, List<ChatRoomCacheDTO> chatRoomCacheDTOS) {
        String cacheKey = CHATROOMCACHEKEY + chatRoomId.toString();
        clubMemberRedisRepository.save(cacheKey, chatRoomCacheDTOS);
    }
}
```

repository

```java
@RequiredArgsConstructor//런타임 전 -> @cacheable -> api 자체를 key value로 저장.  데이터 변동.
@Repository
public class ClubMemberRedisRepository {   //extends CrudRepository<Member, String>

    //@Cacheable -> api 자체를 가지고, 몇초마다 등등으로
    //이런 방식은 key value를  가지고 있는 것.
    private final RedisTemplate<String, List<ChatRoomCacheDTO>> redisTemplate;

    public void save(String key, List<ChatRoomCacheDTO> clubMembers) {
        redisTemplate.opsForValue().set(key, clubMembers);
    }
    //List<clubMember>   ->string 변경 불가 ( redis 어차피 string,String 쌍이다.

    public List<ChatRoomCacheDTO> findAll(String key) {
        return redisTemplate.opsForValue().get(key);
    }
    public void delete(String key) {
        try {
            redisTemplate.delete(key);
        }catch (Exception e){
            log.info("redis delete error!!!!");
        }
    }
}
```

위 2개의 캐시를 통해, 채팅방 진입시에 채팅 방 내의 모든 유저 id를 캐시로 가져오고, 이 id를 통해 또다시 유저 캐시를 탐색하여 각유저의 fcmToken을 가져올 수 있다.

### 사용 예시

**캐싱**

```java
public List<ChatRoomCacheDTO> findAllChatRoomCacheDTOByChatRoomId(Long chatRoomId) { 
        String cacheKey = "chatroom:" + chatRoomId.toString();
            List<ChatRoomCacheDTO> clubMembers=clubMemberRedisRepository.findAll(cacheKey); //stream() 써서    FcmDTO 리스트로 변환   -> 이걸 캐싱하자..!
            if (clubMembers != null) {
                log.info("find chache key: "+cacheKey);
                log.info(clubMembers.get(0).getChatRoomId());
                return clubMembers;
                // 캐시에서 데이터를 가져올 수 없는 경우 DB에서 데이터를 가져와 캐시에 저장합니다.
            }
            List<MemberChatRoom> memberChatRooms = findAllByChatRoomIdWithChatRoomAndClubMember(chatRoomId);
            List<ChatRoomCacheDTO> chatRoomCacheDTOS = memberChatRoomToChatRoomFcmDTOList(memberChatRooms);
            clubMemberRedisRepository.save(cacheKey, chatRoomCacheDTOS);
            return chatRoomCacheDTOS;

    }
```

**캐시 제거**

```java
@Override
    public ChatRoomInviteResponse inviteMembersToChatRoom(List<Long> memberIds, Long chatRoomId) {//다수의 멤버를 채팅방에 추가.
        ChatRoom findChatRoom = chatRoomService.findEntityById(chatRoomId);
        for (Long memberId : memberIds) {
            inviteMemberToChatRoom(memberId, findChatRoom);
        }
        String cacheKey = "chatroom:" + chatRoomId.toString();
        log.info("delete chache key: "+cacheKey);
        clubMemberRedisRepository.delete(cacheKey);
        return new ChatRoomInviteResponse(findChatRoom.getMemberCount());
    }
```

채팅방 초대, 채팅방 떠나기 등 채팅하는 멤버의 구성에 변화가 생기면 캐시를 제거합니다. ( 자바 컬렉션이 value이기에, update 보다 제거 후 다시 캐시를 가져오는 것의 cost가 더 낮을 가능성이 높다.)

### Caching Result analysis

[캐싱 분석 문서](https://www.notion.so/cache-test-a83cfcc2d4434edbb984d476f104fee5?pvs=21)

## fcm push 최적화

### 비동기 처리

**기존( 동기 )**

1. 사용자가 가지고 있는 토큰들을 조회합니다.
2. 해당 토큰과 푸시 메세지 정보를 FCM 서버로 전송합니다.
3. FCM 서버에서 응답이 정상적으로 올 때 까지 기다립니다.
4. 다음 토큰을 조회하여 푸시 메세지 정보를 FCM 서버로 전송합니다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%2010.png)

request - response 사이에 해당 스레드는 IO Blocking이 걸리고, 동기 처리이기에 Blocking이 걸린 시간동안 다른 작업을 수행하지 않기에, request - response 가 많아질수록 성능이 기하급수적으로 감소합니다.

채팅방의 인원이 많아질 수록, 성능이 매우 낮아지는 것 입니다.

**변경( 비동기 )**

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%2011.png)

해당 스레드의 IO Blocking 시간동안, response를 기다리지 않고, 다른 작업을 수행할 수 있습니다.

이를 기반으로한 전체적인 코드의 흐름은 다음과 같습니다. 

최상위 메소드는 메세지를 DB에 저장 후, 채팅방내 자신을 제외한 모든 멤버에게 fcm Push를 수행하는 `sendMessageToMemberExceptMe`를 호출합니다.

`sendMessageToMemberExceptMe`는 채팅방 내의 유저 1명 1명에게 fcm push를 수행하는 `sendMessageTo`메서드를 수행합니다.

`sendMessageTo`메서드는 okhttp를 사용해서 비동기적으로 fcm API와 통신하여 알림을 각 유저에게 보내고, 에러를 처리하는 `asyncRequestAndResponse`메서드를 수행합니다.

아래는, okhttp를 사용하여 async 방식으로 fcm API를 사용하도록 개선한  `asyncRequestAndResponse`메소드입니다.

개선**된 코드 ( async )**

```java
public void asyncRequestAndResponse(OkHttpClient client, Request request,String senderName,String message,String targetFcmToken) { 
        client.newCall(request).enqueue(new Callback() { 
            @Override
            public void onFailure(Call call, IOException e) { //response 가 반환되지 않음.
                log.error("FCM PUSH FAILURE  \n" + e.toString());
                log.error("sender: {}, targetToken: {}, message: {}",senderName,targetFcmToken,message);
            }
            @Override
            public void onResponse(Call call, Response response) {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) { //http 상태코드 체크
                        log.error("FCM PUSH NOT SUCCESSFUL");
                        log.error("sender: {}, targetToken: {}, message: {}",senderName,targetFcmToken,message);
                    }
                    responseBody.string();
                } catch (IOException e) {
                    throw new RestApiException(CommonErrorResponseCode.IO_ERROR);
                }
                response.body().close();
            }
        });
    }
```

**`client.newCall(request).enqueue(new Callback() { ... })`**는 OkHttp 라이브러리에서 비동기적인 HTTP 요청을 수행하기 위한 메서드입니다. 요청을 보낸 후 응답을 비동기적으로 처리하는 역할을 합니다.

콜백 객체를 생성하고 **`enqueue()`** 메서드에 전달함으로써 비동기적인 요청이 이루어집니다. 이 콜백 객체는 두 가지 메서드를 구현해야 합니다:

1. **`onFailure(Call call, IOException e)`**: 요청이 실패한 경우 호출되는 메서드입니다. **`IOException`** 매개변수를 통해 실패한 이유를 확인할 수 있습니다. 예를 들어 네트워크 연결 오류가 발생한 경우 이 메서드가 호출됩니다.

1. **`onResponse(Call call, Response response)`**: 요청에 대한 응답을 받았을 때 호출되는 메서드입니다. **`Response`** 객체를 통해 응답에 관련된 정보를 확인할 수 있습니다. 응답이 성공적이었는지 여부를 확인하고, 필요한 작업을 수행할 수 있습니다. 예를 들어, 응답이 성공적이지 않은 경우 **`response.isSuccessful()`**를 통해 상태 코드를 확인할 수 있습니다. 응답의 내용은 **`responseBody.string()`**을 통해 문자열로 얻을 수 있습니다.

앞서 말했듯이 비동기적으로 요청을 처리하면 애플리케이션은 응답을 기다리는 동안 다른 작업을 수행할 수 있습니다. 이는 응답 시간이 긴 작업이나 여러 요청을 동시에 처리해야 할 때 유용합니다.

하지만, 비동기 처리에는 몇가지 단점이 존재합니다.

1. 디버깅 및 추적의 어려움: 비동기 코드는 일련의 이벤트와 콜백으로 이루어져 있기 때문에 디버깅이 어려울 수 있습니다. 동기 처리의 경우에는 코드의 흐름을 쉽게 따라갈 수 있지만, 비동기 처리는 여러 개의 이벤트와 콜백이 복잡하게 얽혀있기 때문에 버그를 추적하기 어려울 수 있습니다.
2. 오류 처리의 어려움: 비동기 코드에서 발생하는 오류를 처리하기가 상대적으로 어렵습니다. 콜백 중첩이나 오류 처리의 부재로 인해 예외가 쉽게 누락될 수 있습니다. 또한, 비동기 코드에서 발생한 오류를 처리하기 위해 추가적인 로직이 필요할 수 있습니다.

이러한 문제를 해결하기 위해, 저는 [logback](https://www.notion.so/logback-2b319c3201b84784814bf9742b212a1b?pvs=21) 을 사용했습니다.

이를 통해 다음과 같이 문제를 완화할 수 있었습니다.

1. 디버깅 및 추적의 어려움: logback를 사용하면 비동기 코드에서 발생한 문제를 로그로 기록할 수 있습니다. 이를 통해 어떤 이벤트 또는 콜백에서 문제가 발생했는지 추적할 수 있습니다. 로그에는 스택 트레이스와 함께 해당 이벤트 또는 콜백에 대한 정보가 포함될 수 있으므로 디버깅에 도움이 될 수 있습니다.
2. 오류 처리의 어려움: 비동기 코드에서 발생한 오류를 [logback](https://www.notion.so/logback-2b319c3201b84784814bf9742b212a1b?pvs=21) 을 통해 로그로 기록하면, 예외가 누락되지 않고 기록될 수 있습니다. 이를 통해 어떤 오류가 발생했는지 파악할 수 있으며, 필요한 경우 추가적인 오류 처리 로직을 수행할 수 있습니다.

asyncRequestAndResponse는 aync, non-blocking 방식의 처리를 수행고, 일련의 이벤트와 콜백으로 이루어져 있습니다.

그렇기에 당연히 asyncRequestAndResponse를 호출한 호출 메소드(sendMessageTO 라는 1대1 메세지 전송 로직이 담긴 메서드 입니다) 는 해당 메소드의 제어를 처리하지 않습니다.

따라서 asyncRequestAndResponse 메소드 내에서 모든 에러 처리를 수행하였고, IOException을 제외한 예외가 발생한다면,

[logback](https://www.notion.so/logback-2b319c3201b84784814bf9742b212a1b?pvs=21) 을 통해 기록하고, 별도의 처리는 수행하지 않습니다.

이렇게 하는 것으로 만약 유저가 채팅방 내 다수의 유저에게 채팅 알림을 보내던 중, 특정 유저에게 보내는 요청이 실패하더라도, logback을 통해 기록될 뿐, 요청 자체가 실패하지 않습니다.

따라서 유저가 “메세지 전송 실패” 라는 최악의 유저 경험을 겪을 가능성이 비약적으로 줄어들어 유저 사용성의 향상을 도모하였습니다.

해당 로직의 에러 처리 관련 정보를 확인하시려면 아래 링크로 들어가세요.

[**메세지 전송 에러 처리**](https://www.notion.so/4439cf07a54e4fbdb4804c0fd29d8a01?pvs=21) 

**기존 (sync)**

```java
try (Response response = client.newCall(request).execute()) {// try catch resources. 파일 입출력 같이, 반드시 닫아야하는 걸 자동으로 닫아준다.
                if (!response.isSuccessful()) {
                    throw new Exception("error: " + response.code() + " " + response.body().toString());
                }
            }
```

## 메세지 전송 예외 처리

다수에게 메세지를 전송했을 때, 몇명에게는 전송이 실패하더라도, log파일에 기록한 뒤, 나머지 유저에게는

성공적으로 메세지를 전송합니다. (DB는 체크 예외에 대해 롤백을 수행하지 않기에, 해당 유저는 바로 메세지를 받지 못하더라도, 재접속 시, DB에 성공적으로 저장한 메세지를 불러와서 해당 메세지를 확인할 수 있습니다.) 

자세한 구현은 아래 목록을 참고하세요.

[logback](https://www.notion.so/logback-2b319c3201b84784814bf9742b212a1b?pvs=21) 

[**메세지 전송 에러 처리**](https://www.notion.so/4439cf07a54e4fbdb4804c0fd29d8a01?pvs=21) 

# Transaction Rule

## Rule 1: 최상위 서비스 메소드에서 트랜잭션 수행

- Controller 는 1개의 Service 메소드를 사용하여 서비스 코드 내부로 진입하고, 이 최상위 메소드에 @Transactional 어노테이션을 통해 트랜잭션을 수행합니다.

```java
@PostMapping("auth/reissue")
    public ResponseEntity<RootResponse> reissue(@RequestBody ReissueRequest reissueRequest) {
        return ResponseUtil.getInstance().getResponseEntity(HttpStatus.OK, clubMemberService.memberReissue(reissueRequest), null);
    }
```

### **최상위 서비스 메소드 예시**

```java
@Transactional//ok
    public Token memberReissue(ReissueRequest reissueRequest) { //member, userToken 한번에 fetch join!
        Long id = validateAndExtractTokens(reissueRequest);
        ClubMember clubMember = getClubMemberWithUserTokenById(id);
        String refreshToken = clubMember.getUserToken().getRefreshToken();
        isExistRefreshTokenInDB(reissueRequest, refreshToken);
        Token token = jwtUtil.generateToken(id);
        this.updateRefreshToken(clubMember, token.refreshToken);
        this.save(clubMember); //Token이 변경감지로 업데이트 x
        return token;
    }
```

### Rule 2 PURPOSE

이 프로젝트는 Rest API를 준수하는 프로젝트이며, 각 API마다 하나의 논리단위로 묶인 작업을 수행합니다.

따라서 각 API를 하나의 트랜잭션 내에 넣어둠으로써, ACID 규칙이 지켜지게 하여 문제 상황에 rollback() 을 수행하는 등 원활한 동작을 야기합니다.

## Rule2: 읽기만 발생하는 트랜잭션은 readOnly 트랜잭션으로

read만 수행되는 작업의 경우, read만 수행되는 최상위 메소드에 `@Transactional(readOnly = true)`

를 통해, 이후의 로직에서 read 작업만 수행될 것을 나타내는 동시에 성능 최적화를 수행합니다.

## **read 수행 메소드 예시**

```java
@Transactional(readOnly = true)
    public ClubMember getClubMemberWithUserTokenById(Long id) {
        ClubMember clubMember = memberRepository.getClubMemberWithUserTokenById(id);
        if (clubMember == null) throw new RestApiException(CommonErrorResponseCode.RESOURCE_NOT_FOUND);
        return clubMember;
    }
```

### Rule 1 PURPOSE

**readOnly 트랜잭션의 성능상 이점**

1) 프레임워크(JPA):

- JPA는 읽기 전용 트랜잭션에서 커밋시점에 플러시를 호출하지 않습니다.(JPA는 Delay Write로, 커밋시점에 한번에 Write하고 Flush 수행하여 Write를 반영, 하지만 read만수행된다면, flush해서 DB에 적용시킬 필요가 없기에 **쓸데없는 flush 호출을 하지 않습니다**.)
- 또한 추가로 **변경또한 필요가 없기에, 변경감지를 위한 스냅샷 객체도 생성하지 않습니다**.

2) JDBC 드라이버

- 읽기(읽기 전용), 쓰기(읽기도 가능) DB를 구분해서 요청합니다. 따라서 각각 다른 DB 커넥션을 획득해서 사용합니다.

이때의 장점은?

- 분산된 부하: 읽기 작업이 쓰기 작업에 영향을 주지 않고 병렬로 처리될 수 있습니다. Read 끼리는 순서상관없이 수행해도 아무런 문제가 없지만, Write, Read가 혼재되어있다면 올바른 결과를 도출하기 위해 많은 처리가 필요합니다(실제 transaction은 Serializable하지 않기에)

즉 읽기와 쓰기 작업이 동시에 수행될 때 데이터베이스 서버의 부하를 분산시킬 수 있습니다.

- **읽기 성능 향상**: 별도의 읽기용 데이터베이스를 사용하면 읽기 작업이 주로 수행되는 경우에 대한 성능을 향상시킬 수 있습니다. ****읽기용 데이터베이스는 복제된 데이터를 가지고 있으므로, 복제된 데이터베이스를 통해 읽기 작업을 처리함으로써 쓰기 작업에 영향을 주지 않고 응답 시간을 단축시킬 수 있습니다.
- **데이터 일관성 유지**: 별도의 읽기용 데이터베이스는 주로 복제된 데이터를 가지고 있으므로, 쓰기 작업이 수행되는 동안에도 읽기 작업은 이전에 쓰기 작업이 완료된 시점의 일관된 데이터를 제공합니다. 이를 통해 읽기 작업 중에 데이터 일관성을 유지할 수 있습니다.

3) **데이터베이스**

- 읽기 전용 트랜잭션으로 선언된 트랜잭션은 다양한 이점이 생깁니다.

이유: Read Lock끼리는 리소스 공유가 가능합니다. read만 사용되기에 큰 제한사항을 걸게되고, 예상범위가 좁아집니다.

- **리소스 활용 최적화**: 읽기 전용 트랜잭션은 쓰기 작업이 없기 때문에 데이터베이스 리소스를 쓰기 작업에 비해 더 효율적으로 활용할 수 있습니다. ****쓰기 작업에 비해 더 적은 록 충돌이 발생(Read 락 끼리는 같이 사용 가능)하고, 트랜잭션 로그를 기록하는 등의 부담도 적기 때문에 처리 성능이 향상될 수 있습니다.
- **응답 시간 단축**: 읽기 전용 트랜잭션은 **쓰**기 작업에 영향을 받지 않고 데이터를 조회하기 때문에 응답 시간을 단축시킬 수 있습니다. ****읽기 작업은 디스크에 대한 접근이 적고, 데이터를 캐시에 저장하는 등의 최적화를 통해 빠른 응답을 제공할 수 있습니다.
- **동시성 제어 감소**: 읽기 전용 트랜잭션은 동시에 여러 개의 트랜잭션이 수행되더라도 데이터의 일관성을 유지할 수 있습니다. 따라서, 동시성 제어를 위한 록 충돌 등의 오버헤드를 줄일 수 있으며, 동시에 많은 수의 읽기 요청을 처리할 수 있습니다.

# logback

배포 환경에서는 디버깅을 로컬처럼 수행할 수 없기에, log파일을 기록합니다.

## 비동기 방식의 AsyncAppender

sync 방식의 RollingFileAppender이 아닌, 비동기 방식의 AsyncAppender 로 logback을 처리합니다.

**장점**

- 비동기 방식을 사용하기에 대기 시간이 없어지고, 동기 방식에 비하여 로그를 남기는데 있어서 성능상 빨라집니다.

**단점**

- queueSize를 너무 작게 하는 경우 WARN, ERROR를 제외하고 로그의 손실을 가져올 수 있습니다.
- 버퍼를 이용하니 메모리의 사용량이 증가하고 CPU 사용량 또한 증가합니다.
- 중간에 서버가 shutdown되는 경우에 버퍼에 로그가 남아 있으면 버퍼의 로그를 다 쓰기 전에 종료되어 손실이 발생합니다.

따라서 대용량의 트래픽을 받으면서 로그를 많이 남겨야 하는 서비스의 경우는 비동기 방식의 AsyncAppender를 사용하는 것이 좋지만, 그렇지 않은 경우 동기 방식의 RollingFileAppender도 좋은 선택으로 보입니다.

하지만 현재 프로젝트는 자신외의 모든 유저에게 메세지를 보내고, 각각의 전송이 실패하면 log에 기록되기에, 

비동기 방식으로 처리하였습니다.(대규모 트래픽이 존재하지 않는 토이 프로젝트이지만, 대규모를 가정하고 구현하였습니다.)

## logback.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="30 seconds">
    <property name="LOG_PATH" value="./logs"/>
    <property name="LOG_FILE" value="${LOG_PATH}/logback.log"/>
    <property name="LOG_PATTERN"
              value="%d{yyyy-MM-dd HH:mm:ss.SSS,Asia/Tokyo} %-5level [%thread,%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}] %logger{36} [%file:%line] - %msg ##%n"/>

    <!-- async logging on file-->
    <appender name="ROLLING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}</fileNamePattern>
            <maxHistory>5</maxHistory>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
    </appender>

    <!-- ROLLING_FILE appender를 AsyncAppender가 참조하도록 한다 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="ROLLING_FILE"/>
        <queueSize>256</queueSize>
        <discardingThreshold>20</discardingThreshold>
        <includeCallerData>true</includeCallerData>
        <maxFlushTime>10</maxFlushTime>
        <neverBlock>true</neverBlock>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
    </appender>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{36} - %msg%n</Pattern>
        </layout>
    </appender>

    <!-- root 부터, info 이상만 노출시킨다. -->
    <root level="INFO">
        <!-- filter로 error 이상만 실제 파일에 저장된다. -->
        <appender-ref ref="ASYNC_FILE"/>
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
```

- 비동기 로깅을 통해 파일에 로깅을 수행했습니다.  로깅 작업이 백그라운드에서 처리되어 메인 코드의 실행 속도에 직접적인 영향을 주지 않도록 최적화했습니다.
- INFO 레벨 이상의 로그는 콘솔에 기록되고,  ERROR레벨 이상의 로그가 발생한다면,

ASYNC_FILE 에 걸린 필터의 ERROR 레벨 이상 조건을 통과하며 logback.log 파일에 기록됩니다.

- 즉 로그 레벨이 info이상이고, Error 미만인 에러는 콘솔에만 기록되고,

로그 레벨이 **Error이상인 에러**는 콘솔에 출력되는 것에 더해 **./logs/logback.log 파일에 기록됩니다.**

## logback.log 파일에 기록된 에러 예시

```
2023-06-02 16:35:01.142 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:144] - 159 to 160 message error ##
2023-06-02 16:35:01.143 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:145] - failed user fcm Token = c635uHjNNkA8jLjBS8yLYd:APA91bHdsSMdw16keVgO8l61lvLN6idHhzbl3X1S3ucO_L-FJgUHSyQsUf6SAZFw7f_VLtQwgyZpBZ6MlViVzAW7hWgAzt9m5v6UFmCbNXLQka3ZI8HMoJnh84xr26XdiWwZDPf_b2sz ##
2023-06-02 16:35:01.143 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:146] - error message=message ##
com.example.clubsite.exhandler.exception.BuisnessException: null
```

# Error Handling

## Error Response

### Common Error Response

기본적인 에러에 대한 error response 입니다.

```java
public enum CommonErrorResponseCode implements ErrorResponseCode {

    INVALID_PARAMETER(HttpStatus.BAD_REQUEST, "Invalid parameter included"),
    UNAUTHORIZED(HttpStatus.UNAUTHORIZED, "UNAUTHORIZED"),

    RESOURCE_NOT_FOUND(HttpStatus.BAD_REQUEST, "Resource not exists"),

    BAD_REQUEST(HttpStatus.BAD_REQUEST, "Bad Request"),

    INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "Internal server error"),
    FILE_IO_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "IO Exception occur"),

    ;

    private final HttpStatus httpStatus;
    private final String message;

}
```

### Custom Error Response

특수하게 잡아서 처리해줘야하는 에러들을 모아둔 Custom Error Response 입니다.

```java

public enum HNHResponseCode {
    SEND_MESSAGE_FAIL(40010, "HNH sendMessage Fail"),
    INVALID_USER_EMAIL(40011, "HNH ERROR no user with such email"),
    ALREADY_EXIST_CHATROOM(40012, "HNH ERROR already exist chatRoom resource"),
    ;
    private final Integer statusCode;
    private final String message;
}

```

ex)

이미 존재하는 채팅방을 생성하려고 시도할 때 아래와 같이 특수한 Custom Error Code를 통해 Front에서 

“존재하지 않는 유저입니다!” 와 같은 에러를 도출해낼 수 있다.

```json
{
    "responseCode": 40011,
    "responseMessage": "HNH ERROR no user with such email",
    "responseData": null,
    "pageInfo": null
}
```

### Business Error Code

```java
public enum BusinessErrorCode {
    SEND_MESSAGE_FAIL(50001, "Business Exception: sendMessage Fail")
    ;
    private final Integer statusCode;
    private final String message;
}
```

비즈니스 로직으로 의도적으로 발생시키는 예외는 아니지만, 다수에게 메세지 전송 중 소수의 인원에게 메세지 전송 실패 시에 log에 기록하고 성공시키는 로직을 수행 중이기에, Business 예외와 유사성 때문에 이렇게 명명하였습니다. 

## RestControllerAdvice

컨트롤러 영역의 에러를 controller advice를 통하여 처리

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(RestApiException.class)
    public ResponseEntity<RootResponse> handleRestException(final RestApiException e) {
        //if(e.getErrorCode().getHttpStatus()!=HttpStatus.UNAUTHORIZED) reissue 관련
            e.printStackTrace();
        return handleExceptionInternal(e.getErrorCode(),e.getMessage());
    }

    @ExceptionHandler(HNHException.class)
    public ResponseEntity<RootResponse> handleHNHException(final HNHException e) {
        e.printStackTrace();
        return handleExceptionInternal(e.getErrorCode(),e.getMessage());
    }

    @ExceptionHandler({Exception.class}) //그외의 에러들 ( unhandled )
    public ResponseEntity<RootResponse> handleAllException(final Exception e) {
        log.info("handleAllException", e);
        final ErrorResponseCode errorCode = CommonErrorResponseCode.INTERNAL_SERVER_ERROR;
        return handleExceptionInternal(errorCode,null);
        //return handleExceptionInternal(errorCode,"unhandled exception!");
    }

    private ResponseEntity<RootResponse> handleExceptionInternal(final HNHResponseCode errorCode,String message) {
        return ResponseUtil.getInstance().getResponseEntity(errorCode.getStatusCode(),errorCode.getMessage() ,null, null);
        //return ResponseUtil.getInstance().getResponseEntity(errorCode.getStatusCode(),errorCode.getMessage() ,message, null);
    }
    private ResponseEntity<RootResponse> handleExceptionInternal(final ErrorResponseCode errorCode,String message) {
        return ResponseUtil.getInstance().getResponseEntity(errorCode.getHttpStatus() ,null, null);
       // return ResponseUtil.getInstance().getResponseEntity(errorCode.getHttpStatus() ,message, null);
    }

}
```

## Exception 종류

### Common Exception

```java
@Getter
public class RestApiException extends RuntimeException {
    private final ErrorResponseCode errorCode;
    private final String message;
    public RestApiException(ErrorResponseCode errorCode) {

        this(errorCode, errorCode.getMessage());
    }
    public RestApiException(ErrorResponseCode errorCode, String message) {
        this.errorCode = errorCode;
        this.message = message;
    }
}
```

**언체크 예외**입니다. 통상적인 exception 으로 사용하고, HttpStatus를 통해 상태를 나타냅니다.

### Custom Exception

```java
@Getter
public class HNHException extends RuntimeException {

    private final HNHResponseCode errorCode;
    private final String message;
    public HNHException(HNHResponseCode errorCode,String message){
        this.errorCode=errorCode;
        this.message=message;
    }
    public HNHException(HNHResponseCode errorCode){
        this(errorCode, errorCode.getMessage());
    }

}
```

**언체크 예외** 입니다. 특수한 케이스를 나타내기 위한 예외입니다. StatusCode 가 400xx와 같은 `Integer` 타입입니다.

### BusinessException

```java
@Getter
public class RestApiException extends Exception {
    private final ErrorResponseCode errorCode;
    private final String message;
    public RestApiException(ErrorResponseCode errorCode) {

        this(errorCode, errorCode.getMessage());
    }
    public RestApiException(ErrorResponseCode errorCode, String message) {
        this.errorCode = errorCode;
        this.message = message;
    }
}
```

**체크 예외** 입니다. 의도적으로 발생한 예외, 혹은 해당 예외를 report하되, 실패 처리를 수행하지 않는 경우에 사용합니다.

## Exception Handling

모든 Exception은 ReuntimException을 상속받아 unchecked Exception을 기본으로 합니다.

### checked Exception Handling

SQLException의 경우, JPA에서 예외 변환 AOP를 통해 수행하고, queryDSL의 경우 @Repository 어노테이션으로 예외 변환 AOP의 대상이 되기에, 따로 처리하지 않습니다.

남은 checked Exception들은 IOException과 그 하위의 Exception들인데( UnsupportedEncodingException) 이 경우 try catch를 통해 에러를 catch한 뒤, Controller Advisor에서 처리하도록 예외를 throw하는 것으로 구현하였습니다. 

```java
try {
				........
        } catch (UnsupportedEncodingException e) {
            throw new RestApiException(CommonErrorResponseCode.IO_ERROR, e.getMessage());
        }

try {
          ......
        } catch (IOException e) {
            throw new RestApiException(CommonErrorResponseCode.IO_ERROR, e.getMessage());
        }
```

### **메세지 전송 에러 처리**

```java
for (ChatRoomCacheDTO chatRoomMemberExceptMe : allMemberInChatRoom) {//id, fcmToken ->FcmDTO
          ...........
            try {   
                fcmService.sendMessageTo(xxx);//fcm push 전송 로직
            }
            }catch (CheckedException e){
                writeErrorLog(clubMember.getId(), chatRoomMemberExceptMe, findFcmToken, e);
            }
        }
```

```java
public boolean sendMessageTo(Payload payload, String targetToken, String title, String body) throws CheckedException {
        OkHttpClient client = new OkHttpClient();
        String message = makeMessage(payload, targetToken, title, body);
        RequestBody requestBody = RequestBody.create(message, MediaType.get(APPLICATION_JSON_CHARSET_UTF_8));
        Request request = null;
        try {
            request = getRequest(requestBody);
        } catch (IOException e) {
            throw new CheckedException(CheckedErrorResponseCode.CHECKED_IO_ERROR);
        }
        asyncRequestAndResponse(client, request, payload.getNickName(), payload.getMessage(), targetToken);
        return true;
    }
```

메세지 전송자가 다수에게 메세지 전송 시, 다수 중 1명에게 메세지 전송이 실패하더라도, 성공한 사람들에게는 메세지를 전송하고, 실패한 사람은 *`writeErrorLog`* 메소드를 통해 따로 logback을 통해 기록을 남겨 문제를 내부적으로 처리합니다.

단, asyncRequestAndResponse의 경우, 비동기 방식( 이벤트 콜백을 통해) 이루어지기에, 이곳에서 별도로 흐름을 제어하지 않습니다.

sendMessageTo 메소드가 실패 시, checked 예외로 만든 비즈니스 예외를 throw하고, 상위의

`sendMessageToMemberExceptMe`에서 해당 예외를 받아서 log.error() 로 로그를 기록합니다.

log.error() 만 남길시에, 굳이 상위로 check 예외를 넘길 필요는 없지만, 추후 변경 가능성을 고려하여 구현하였습니다.

아래는 특정 유저에게만 메세지 전송 실패 시, logback.log 파일에 기록되는 log 입니다.

```
2023-06-02 16:35:01.142 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:144] - 159 to 160 message error ##
2023-06-02 16:35:01.143 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:145] - failed user fcm Token = c635uHjNNkA8jLjBS8yLYd:APA91bHdsSMdw16keVgO8l61lvLN6idHhzbl3X1S3ucO_L-FJgUHSyQsUf6SAZFw7f_VLtQwgyZpBZ6MlViVzAW7hWgAzt9m5v6UFmCbNXLQka3ZI8HMoJnh84xr26XdiWwZDPf_b2sz ##
2023-06-02 16:35:01.143 ERROR [http-nio-8080-exec-5,,,] c.e.clubsite.service.ChatServiceImpl [ChatServiceImpl.java:146] - error message=message ##
com.example.clubsite.exhandler.exception.BuisnessException: null
```

“보낸 유저의 id to 받는 유저의 id” 가 로그에 기록되고, 메세지를 받았어야할 유저의 fcmToken을 기록합니다.

sendMessageTo 로직은 메세지를 DB에 저장하는 것과 별개로, 메세지를 받을 모든 유저에게 FCM을 통해 알림을 전송하는 메소드이기에, fcmToken을 가지고 문제상황을 확인할 수 있습니다.

# Test Code

## chatServiceTest

fcm push 부분을 포함한 외부 의존성들을 mock 객체로 대체하고, 순수한 chating 수행 로직을 테스트 했습니다. 

```java
@Slf4j
class ChatServiceImplTest {
    @Mock
    private ChatRoomService chatRoomService;

    @Mock
    private ClubMemberService clubMemberService;
    @Mock
    private ChatRepository chatRepository;

    @Mock
    private FCMService fcmService;

    @Mock
    private RoomMemberRedisService roomMemberRedisService;
    @Mock
    private MemberChatRoomService memberChatRoomService;

    @Mock
    private UrlUtil urlUtil;

    @Mock
    MemberTokenRedisService memberTokenRedisService;

    //@Spy//스터빙을 안 한 테스트는 기존 객체의 로직을, 스터빙을 한 테스트는 스터빙 값을 리턴
    @InjectMocks //mock을 주입받아 실제 객체 생성
    @Spy
    private ChatServiceImpl chatService;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void addChatTest() throws CheckedException {//BuisnessException 없애고 에러 테스트 수행하자! ( 몇명 성공, 몇명 실패 케이스 )
        // given
        Long chatRoomId = 1L;
        String message = "hello";

        List<Long> receiverIds = new ArrayList<>(Arrays.asList(2L, 3L));//자신 외의 채팅방 내 멤버들 설정
        List<ClubMember> receivers = buildMembersWithUserTokenByIds(receiverIds); //멤버와 그 연관된 객체를 임의로 생성.
        ChatRoom chatRoom = ChatRoom.builder().chats(Collections.emptyList()).build();
        ClubMember sender = makeClubMember(1L, "sender@gmail.com", "senderTestName", "senderTestImage"); //메세지 전송하는 사람
        Chat chat = Chat.builder().chatRoom(chatRoom).clubMember(sender).message(message).build();//sender가 전송한 hello 메세지 객체 생성.

        // when
        when(chatRoomService.findEntityById(chatRoomId)).thenReturn(chatRoom);
        when(clubMemberService.findEntityById(sender.getId())).thenReturn(sender);
        when(roomMemberRedisService.findChatRoomMembersCacheByChatRoomId(chatRoomId)).thenReturn(new ArrayList<>());//채팅방 멤버 캐시 비어있을 때 가정.
        when(chatRepository.save(any())).thenAnswer(invocation -> invocation.getArgument(0)); //save 성공 가정 -> 바로 엔티티 반환

        List<ChatRoomCacheDTO> allMemberInChatRoom = getChatRoomCacheDTOs(chatRoomId,sender.getId(), receiverIds);//전송자, 그외 멤버들 로 채팅 방 멤버 객체 생성
        when(memberChatRoomService.getAllMembersInChatRoomAsChatRoomCacheDTOs(chatRoomId)).thenReturn(allMemberInChatRoom); //바로 객체 가져오기

        when(urlUtil.getProfileUrlWithUrl(anyString())).thenAnswer(invocation -> invocation.getArgument(0)); //이미지 파일 그냥 그대로( 앞에 url x)

        when(memberTokenRedisService.getMemberTokenCacheByClubMemberId(any())).thenReturn(Optional.empty());// 캐시 존재 x 가정

        getAllClubmemberWithUserTokenByIdMock(receivers);

        doNothing().when(fcmService).sendMessageTo(any(), anyString(), anyString(), anyString());// void 메소드가 아무것도 수행하지 않게 하기

        //then
        chatService.addChat(sender.getId(), chatRoomId, message);

        for (ClubMember receiver : receivers) {
            verify(fcmService, times(1)).sendMessageTo( //자신을 제외한 유저 2명에게, 메세지 전송 메서드가 각각 해서 2번 전송?
                    eq(payloadBuilder(chatRoomId, sender, chat)),
                    eq(receiver.getUserToken().getFcmToken()),
                    eq("walkTalk: " + sender.getName()),
                    eq(chat.getMessage())
            );
        }
    }

    @NotNull
    private static List<ClubMember> buildMembersWithUserTokenByIds(List<Long> receiverIds) {
        List<ClubMember> receivers=new ArrayList<>();
        for (Long receiverId : receiverIds) {
            receivers.add(buildClubMemberWithUserToken(receiverId));
        }
        return receivers;
    }

    private List<ChatRoomCacheDTO> getChatRoomCacheDTOs(Long chatRoomId,Long sender1, List<Long> receivers) {
        List<ChatRoomCacheDTO> allMemberInChatRoom = new ArrayList<>();
        allMemberInChatRoom.add(new ChatRoomCacheDTO(chatRoomId, sender1));
        for (Long receiver : receivers) {
            allMemberInChatRoom.add(new ChatRoomCacheDTO(chatRoomId, receiver));
        }
        return allMemberInChatRoom;
    }

    private static ClubMember makeClubMember(Long id, String email, String name, String imageName) {
        ClubMember registeredClubMember = ClubMember.builder()
                .id(id)
                .email(email)
                .name(name)
                .profileFileName(imageName)
                .build();
        return registeredClubMember;
    }

    private static ClubMember buildClubMemberWithUserToken(Long id) {
        Faker faker = new Faker();
        ClubMember clubMember = ClubMember.builder()
                .id(id)
                .email(faker.internet().emailAddress())
                .name(faker.name().fullName())
                .profileFileName("NOIMAGE")
                .build();
        UserToken userToken = UserToken.builder().fcmToken("testFcmToken:"+clubMember.getName()).refreshToken("testRefreshToken:"+clubMember.getName()).build();
        clubMember.setUserToken(userToken);
        return clubMember;
    }

    private void getAllClubmemberWithUserTokenByIdMock(List<ClubMember> receivers) {
        for (ClubMember receiver : receivers) {
            when(clubMemberService.getClubMemberWithUserTokenById(receiver.getId())).thenAnswer(invocation -> { //주어진 id 에 맞는 moc 객체 가져오기
                Long memberId = invocation.getArgument(0);
                return receiver;
            });
        }
    }

    private Payload payloadBuilder(Long chatRoomId, ClubMember clubMember, Chat chat) {
        return Payload.builder()
                .chatId(chatRoomId)
                .nickName(clubMember.getName())
                .message(chat.getMessage())
                .imagePath(clubMember.getProfileFileName())
                .notiType(NotiType.CHAT.name())
                .linkUrl("not yet")
                .build();
    }
}
```

## Fcm API Test

mockServer를 사용하여, okhttp3를 통해 fcm 과 통신하는 과정을 모사하는 것으로, 1명의 유저에게

fcm API 를 통해 Push를 수행하는 sendMessageTo() 메소드를 테스트하였습니다.

```java
@Slf4j
public class FCMServiceTest { //mockServer를 통해 fcm 서버의 동작을 모사하는 것으로 테스트 수행

    private MockWebServer mockWebServer;
    private FCMService fcmService;

    @BeforeEach
    public void setUp() throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();

        fcmService = new FCMService(new ObjectMapper());
        fcmService.setAPIUrl(mockWebServer.url("/").toString());

        MockitoAnnotations.openMocks(this);
    }

    @AfterEach
    public void tearDown() throws IOException {
        mockWebServer.shutdown();
    }

    @Test
    public void testSendMessageTo() {
        // Given
        String TARGET_TOKEN = "TARGET_TOKEN";
        String TEST_BODY = "Test Body";
        String TEST_TITLE = "Test Title";
        String SENDER_NAME = "senderTestName";
        String TEST_EMAIL = "sender@gmail.com";
        String SENDER_TEST_IMAGE = "senderTestImage";
        String MESSAGE_CONTENT = "hello!";
        Long TEST_ID = 1L;

        // 모의 응답 생성
        MockResponse mockResponse = new MockResponse()
                .setResponseCode(200)
                .setBody("Mock response body");

        // 모의 서버에 응답 설정
        mockWebServer.enqueue(mockResponse);//mock 처럼, 어떤 request가 들어오던, 해당 response를 반환하도록 설정.

        // 테스트에 사용할 Payload, Token, Title, Body 설정
        ClubMember sender = makeClubMember(1L, TEST_EMAIL, SENDER_NAME, SENDER_TEST_IMAGE);
        Payload payload = payloadBuilder(TEST_ID, sender, Chat.builder().message(MESSAGE_CONTENT).chatRoom(ChatRoom.builder().title("chatRoomTitle").build()).build());

        // When
        try {
            fcmService.sendMessageTo(payload, TARGET_TOKEN, TEST_TITLE, TEST_BODY);
        } catch (CheckedException e) {
            throw new RuntimeException(e);
        }

        // 요청이 도착할 때까지 대기
        RecordedRequest recordedRequest = null;
        try {
            recordedRequest = mockWebServer.takeRequest();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //mockWebServer.takeRequest(): mock 서버에 들어온 요청을 가져온다.

        // Then
        // 요청 확인
        assertEquals(mockWebServer.url("/"), recordedRequest.getRequestUrl());
        assertEquals("/", recordedRequest.getPath());
        assertEquals("POST", recordedRequest.getMethod());
        //assertEquals("Bearer <ACCESS_TOKEN>", recordedRequest.getHeader("Authorization"));
        assertEquals("application/json; charset=utf-8", recordedRequest.getHeader("Content-Type"));
        assertEquals("{\"validate_only\":false,\"message\":{\"token\":\"" + TARGET_TOKEN + "\",\"topic\":null,\"notification\":{\"title\":\"" + TEST_TITLE + "\",\"body\":\"" + TEST_BODY + "\",\"image\":null},\"data\":null,\"apns\":{\"payload\":{\"notiType\":\"CHAT\",\"chatId\":" + TEST_ID + ",\"nickName\":\"" + SENDER_NAME + "\",\"imagePath\":\"" + SENDER_TEST_IMAGE + "\",\"message\":\"" + MESSAGE_CONTENT + "\",\"linkUrl\":null,\"aps\":{\"alert\":{\"body\":\"" + SENDER_NAME + ": " + MESSAGE_CONTENT + "\"},\"sound\":\"default\",\"badge\":1}}}}}", recordedRequest.getBody().readUtf8());
    }

    @Test
    public void testSendMessageTo_Failure() {
        // Given
        String TARGET_TOKEN = "TARGET_TOKEN";
        String TEST_TITLE = "Test Title";
        String TEST_BODY = "Test Body";
        String SENDER_NAME = "senderTestName";
        String SENDER_TEST_IMAGE = "senderTestImage";
        String MESSAGE_CONTENT = "hello!";
        String TEST_EMAIL = "sender@gmail.com";
        Long TEST_ID = 1L;

        // 모의 응답 생성
        MockResponse mockResponse = new MockResponse()
                .setResponseCode(500)
                .setBody("Internal Server Error");

        // 모의 서버에 응답 설정
        mockWebServer.enqueue(mockResponse);

        // 테스트에 사용할 Payload, Token, Title, Body 설정
        ClubMember sender = makeClubMember(1L, TEST_EMAIL, SENDER_NAME, SENDER_TEST_IMAGE);
        Payload payload = payloadBuilder(TEST_ID, sender, Chat.builder().message(MESSAGE_CONTENT).chatRoom(ChatRoom.builder().title("chatRoomTitle").build()).build());

        // When
        try {
            fcmService.sendMessageTo(payload, TARGET_TOKEN, TEST_TITLE, TEST_BODY);
        } catch (CheckedException e) {
            throw new RuntimeException(e);
        }

        // 요청이 도착할 때까지 대기
        RecordedRequest recordedRequest = null;
        try {
            recordedRequest = mockWebServer.takeRequest();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        // Then
        // 요청 확인
        assertEquals(mockWebServer.url("/"), recordedRequest.getRequestUrl());
        assertEquals("/", recordedRequest.getPath());
        assertEquals("POST", recordedRequest.getMethod());
        //assertEquals("Bearer <ACCESS_TOKEN>", recordedRequest.getHeader("Authorization"));
        assertEquals("application/json; charset=utf-8", recordedRequest.getHeader("Content-Type"));
        assertEquals("{\"validate_only\":false,\"message\":{\"token\":\"" + TARGET_TOKEN + "\",\"topic\":null,\"notification\":{\"title\":\"" + TEST_TITLE + "\",\"body\":\"" + TEST_BODY + "\",\"image\":null},\"data\":null,\"apns\":{\"payload\":{\"notiType\":\"CHAT\",\"chatId\":" + TEST_ID + ",\"nickName\":\"" + SENDER_NAME + "\",\"imagePath\":\"" + SENDER_TEST_IMAGE + "\",\"message\":\"" + MESSAGE_CONTENT + "\",\"linkUrl\":null,\"aps\":{\"alert\":{\"body\":\"" + SENDER_NAME + ": " + MESSAGE_CONTENT + "\"},\"sound\":\"default\",\"badge\":1}}}}}", recordedRequest.getBody().readUtf8());
    }

    private static ClubMember makeClubMember(Long id, String email, String name, String imageName) {
        ClubMember registeredClubMember = ClubMember.builder()
                .id(id)
                .email(email)
                .name(name)
                .profileFileName(imageName)
                .build();
        return registeredClubMember;
    }

    private Payload payloadBuilder(Long chatRoomId, ClubMember clubMember, Chat chat) {
        return Payload.builder()
                .chatId(chatRoomId)
                .nickName(clubMember.getName())
                .message(chat.getMessage())
                .imagePath(clubMember.getProfileFileName())
                .notiType(NotiType.CHAT.name())
                .linkUrl("not yet")
                .build();
    }

}
```

# 배포

develop, stage, production 서버를 운영 중이고, 각 서버별로 프로필을 나누어서 관리 중입니다.

![Untitled](README%203e9dffa20ab94015a1d524524e0418e8/Untitled%2012.png)

## dv(develop)

환경

- local 환경. mariadb, logback을 통한 로그 파일을 로컬 저장소에서 유치중입니다.

실제 개발 수행 후,테스트를 수행하는  서버입니다. feature 브랜치, 혹은 develop 브랜치에서 개발 중인 코드를 테스트합니다.

## pr(production)

환경

- 개인 ec2서버를 통해 서버, mariadb, redis 이미지를 docker-compose로 배포 중입니다.
- Volume을 통해 redis , 유저 프로필 이미지 파일, logback을 통한 로그 파일을 유치 중입니다.

 어느정도 안정화된 코드를 배포 중 입니다.

docker-compose.yml

```yaml
services:
  server:
    #image: harbor.hnh.ai/server/walktalk:latest #dev.hnh.ai/server/walktalk:latest
    image: shyswy/walktalk:latest #dev.hnh.ai/server/walktalk:latest
    ports:
      - 21903:8080
    depends_on:
      - maria_db
      - redis
    restart: always
    environment:
      - SPRING_PROFILES_ACTIVE=pr
    volumes:
      - ./pr-logs:/Users/yoonsanghyun/pr-logs
      - ./walktalk_file:/Users/yoonsanghyun/walktalk_file/
      - ./src/main/resources/application-${SPRING_PROFILES_ACTIVE}.properties:/path/to/application.properties
  maria_db:
    image: mariadb
    ports:
      - 21904:3306
    volumes:
      - ./maria_db:/var/lib/mysql
      - ./maria_db/conf.d:/var/mysql/my.cnf
    environment:
      MYSQL_DATABASE: xxxxxxxx
      MYSQL_USER: xxxxxxxx
      MYSQL_PASSWORD: xxxxxxxx
      MYSQL_ROOT_PASSWORD: xxxxxxxx
  redis:
    image: redis
    ports:
      - 6379:6379
```

## st(stage)

docker-compose.yml

```yaml
services:
  server:
    image: harbor.hnh.ai/server/walktalk:latest #dev.hnh.ai/server/walktalk:latest
    ports:
      - 21903:8080
    depends_on:
      - maria_db
      - redis
    restart: always
    environment:
      - SPRING_PROFILES_ACTIVE=st
    volumes:
      - ./walktalk_file:/Users/yoonsanghyun/walktalk_file/
      - ./src/main/resources/application-${SPRING_PROFILES_ACTIVE}.properties:/path/to/application.properties
  maria_db:
    image: mariadb
    ports:
      - 21904:3306
    volumes:
      - ./maria_db:/var/lib/mysql
      - ./maria_db/conf.d:/var/mysql/my.cnf
     environment:
      MYSQL_DATABASE: xxxxxxxx
      MYSQL_USER: xxxxxxxx
      MYSQL_PASSWORD: xxxxxxxx
      MYSQL_ROOT_PASSWORD: xxxxxxxx
  redis:
    image: redis
    ports:
      - 6379:6379
```

환경

- 회사의 사내 ec2서버를 통해 서버, mariadb, redis 이미지를 docker-compose로 배포 중입니다.
- Volume을 통해 redis , 유저 프로필 이미지 파일, logback을 통한 로그 파일을 유치 중입니다.

테스트를 수행 후, 어느 정도 신뢰도가 보장된 서버를 배포 중입니다.